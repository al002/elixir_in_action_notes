<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Chapter 10 | Elixir in action notes</title>
<meta name=keywords content><meta name=description content='Tasks


The Task module can be used to concurrently run a job


Awaited tasks

An awaited task is a process that executes some function, sends the function result back to the starter process, and then terminates



iex(1)> long_job =
  fn ->
    Process.sleep(2000)
    :some_result
  end
  
iex(2)> task = Task.async(long_job)

# await will wait response from the task process
# default 5 seconds to timeout
iex(3)> Task.await(task)
:some_result
+ if any task process crashes, the starter process will crash too

+ `Task.async/1` has all-or-nothing semantics


Non-awaited tasks

iex(1)> Task.start_link(fn ->
  Process.sleep(1000)
  IO.puts("Hello from task")
end)

{:ok, #PID<0.89.0>} # Result of Task.start_link/1

Hello from task! # Printed 1 second later

Supervising dynamic tasks

iex(1)> Task.Supervisor.start_link(name: MyTaskSupervisor)

iex(2)> Task.Supervisor.start_child(
  MyTaskSupervisor,
  fn ->
    IO.puts("Task started")
    Process.sleep(2000)
    IO.puts("Task stopping")
  end
)

{:ok, #PID<0.118.0>}
Task started
Task stopping
Agents'><meta name=author content><link rel=canonical href=https://al002.github.io/pages/chapter-10/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://al002.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://al002.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://al002.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://al002.github.io/apple-touch-icon.png><link rel=mask-icon href=https://al002.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://al002.github.io/pages/chapter-10/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Chapter 10"><meta property="og:description" content='Tasks


The Task module can be used to concurrently run a job


Awaited tasks

An awaited task is a process that executes some function, sends the function result back to the starter process, and then terminates



iex(1)> long_job =
  fn ->
    Process.sleep(2000)
    :some_result
  end
  
iex(2)> task = Task.async(long_job)

# await will wait response from the task process
# default 5 seconds to timeout
iex(3)> Task.await(task)
:some_result
+ if any task process crashes, the starter process will crash too

+ `Task.async/1` has all-or-nothing semantics


Non-awaited tasks

iex(1)> Task.start_link(fn ->
  Process.sleep(1000)
  IO.puts("Hello from task")
end)

{:ok, #PID<0.89.0>} # Result of Task.start_link/1

Hello from task! # Printed 1 second later

Supervising dynamic tasks

iex(1)> Task.Supervisor.start_link(name: MyTaskSupervisor)

iex(2)> Task.Supervisor.start_child(
  MyTaskSupervisor,
  fn ->
    IO.puts("Task started")
    Process.sleep(2000)
    IO.puts("Task stopping")
  end
)

{:ok, #PID<0.118.0>}
Task started
Task stopping
Agents'><meta property="og:type" content="article"><meta property="og:url" content="https://al002.github.io/pages/chapter-10/"><meta property="article:section" content="pages"><meta property="article:published_time" content="2024-12-27T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Chapter 10"><meta name=twitter:description content='Tasks


The Task module can be used to concurrently run a job


Awaited tasks

An awaited task is a process that executes some function, sends the function result back to the starter process, and then terminates



iex(1)> long_job =
  fn ->
    Process.sleep(2000)
    :some_result
  end
  
iex(2)> task = Task.async(long_job)

# await will wait response from the task process
# default 5 seconds to timeout
iex(3)> Task.await(task)
:some_result
+ if any task process crashes, the starter process will crash too

+ `Task.async/1` has all-or-nothing semantics


Non-awaited tasks

iex(1)> Task.start_link(fn ->
  Process.sleep(1000)
  IO.puts("Hello from task")
end)

{:ok, #PID<0.89.0>} # Result of Task.start_link/1

Hello from task! # Printed 1 second later

Supervising dynamic tasks

iex(1)> Task.Supervisor.start_link(name: MyTaskSupervisor)

iex(2)> Task.Supervisor.start_child(
  MyTaskSupervisor,
  fn ->
    IO.puts("Task started")
    Process.sleep(2000)
    IO.puts("Task stopping")
  end
)

{:ok, #PID<0.118.0>}
Task started
Task stopping
Agents'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Pages","item":"https://al002.github.io/pages/"},{"@type":"ListItem","position":2,"name":"Chapter 10","item":"https://al002.github.io/pages/chapter-10/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Chapter 10","name":"Chapter 10","description":"Tasks\nThe Task module can be used to concurrently run a job\nAwaited tasks\nAn awaited task is a process that executes some function, sends the function result back to the starter process, and then terminates iex(1)\u0026gt; long_job = fn -\u0026gt; Process.sleep(2000) :some_result end iex(2)\u0026gt; task = Task.async(long_job) # await will wait response from the task process # default 5 seconds to timeout iex(3)\u0026gt; Task.await(task) :some_result + if any task process crashes, the starter process will crash too + `Task.async/1` has all-or-nothing semantics Non-awaited tasks iex(1)\u0026gt; Task.start_link(fn -\u0026gt; Process.sleep(1000) IO.puts(\u0026#34;Hello from task\u0026#34;) end) {:ok, #PID\u0026lt;0.89.0\u0026gt;} # Result of Task.start_link/1 Hello from task! # Printed 1 second later Supervising dynamic tasks iex(1)\u0026gt; Task.Supervisor.start_link(name: MyTaskSupervisor) iex(2)\u0026gt; Task.Supervisor.start_child( MyTaskSupervisor, fn -\u0026gt; IO.puts(\u0026#34;Task started\u0026#34;) Process.sleep(2000) IO.puts(\u0026#34;Task stopping\u0026#34;) end ) {:ok, #PID\u0026lt;0.118.0\u0026gt;} Task started Task stopping Agents\n","keywords":[],"articleBody":"Tasks\nThe Task module can be used to concurrently run a job\nAwaited tasks\nAn awaited task is a process that executes some function, sends the function result back to the starter process, and then terminates iex(1)\u003e long_job = fn -\u003e Process.sleep(2000) :some_result end iex(2)\u003e task = Task.async(long_job) # await will wait response from the task process # default 5 seconds to timeout iex(3)\u003e Task.await(task) :some_result + if any task process crashes, the starter process will crash too + `Task.async/1` has all-or-nothing semantics Non-awaited tasks iex(1)\u003e Task.start_link(fn -\u003e Process.sleep(1000) IO.puts(\"Hello from task\") end) {:ok, #PID\u003c0.89.0\u003e} # Result of Task.start_link/1 Hello from task! # Printed 1 second later Supervising dynamic tasks iex(1)\u003e Task.Supervisor.start_link(name: MyTaskSupervisor) iex(2)\u003e Task.Supervisor.start_child( MyTaskSupervisor, fn -\u003e IO.puts(\"Task started\") Process.sleep(2000) IO.puts(\"Task stopping\") end ) {:ok, #PID\u003c0.118.0\u003e} Task started Task stopping Agents\nprovides an abstraction that’s similar to GenServer\nrequire a bit less ceremony and can, therefore, eliminate some boilerplate associated with GenServer\niex(1)\u003e {:ok, pid} = Agent.start_link(fn -\u003e %{name: \"Bob\", age: 30} end) {:ok, #PID\u003c0.86.0\u003e} iex(2)\u003e Agent.get(pid, fn state -\u003e state.name end) \"Bob\" + execute passed lambda Limitations of agents\ncannot handle plain messages\ncannot run some logic on termination\nETS tables\nETS (Erlang Term Storage) tables are a mechanism that allows you to share some state between multiple processes in a more efficient way\nusecase\nshared key–value structures and counters ETS characteristics\nThere’s no specific ETS data type. A table is identified by its ID (a reference type) or a global name (an atom).\nETS tables are mutable. A write to a table will affect subsequent read operations.\nMultiple processes can write to or read from a single ETS table. Writes and reads might be performed simultaneously.\nMinimum concurrency safety is ensured. Multiple processes can safely write to the same row of the same table. The last write wins.\nAn ETS table resides in a separate memory space. Any data coming in or out is deep copied.\nETS doesn’t put pressure on the garbage collector. Overwritten or deleted data is immediately released.\nAn ETS table is deeply connected to its owner process (by default, the process that created the table). If the owner process terminates, the ETS table is reclaimed.\nOther than on owner-process termination, there’s no automatic garbage collection of an ETS table. Even if you don’t hold a reference to the table, it still occupies memory.\niex(1)\u003e table = :ets.new(:my_table, []) #Reference\u003c0.970221231.4117102596.53103\u003e iex(2)\u003e :ets.insert(table, {:key_1, 1}) true iex(3)\u003e :ets.insert(table, {:key_2, 2}) true iex(5)\u003e :ets.lookup(table, :key_1) [key_1: 3] table types\n:set—This is the default. One row per distinct key is allowed\n:ordered_set—This is just like :set, but rows are in term order (comparison via the \u003c and \u003e operators)\n:bag—Multiple rows with the same key are allowed, but two rows can’t be completely identical\n:duplicate_bag—This is just like :bag, but it allows duplicate rows\ntable permissions\n:protected—This is the default. The owner process can read from and write to the table. All other processes can read from the table\n:public—All processes can read from and write to the table\n:private—Only the owner process can access the table\nfull-blown match specification\n:ets.select/2\nhttps://erlang.org/doc/man/ets.html#select-2\nmake task simpler\nex2ms\nhttps://github.com/ericmj/ex2ms ","wordCount":"520","inLanguage":"en","datePublished":"2024-12-27T00:00:00Z","dateModified":"2025-01-05T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://al002.github.io/pages/chapter-10/"},"publisher":{"@type":"Organization","name":"Elixir in action notes","logo":{"@type":"ImageObject","url":"https://al002.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://al002.github.io/ accesskey=h title="Elixir in action notes (Alt + H)">Elixir in action notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Chapter 10</h1><div class=post-meta><span title='2024-12-27 00:00:00 +0000 UTC'>December 27, 2024</span></div></header><div class=post-content><p>Tasks</p><ul><li><p>The Task module can be used to concurrently run a job</p></li><li><p>Awaited tasks</p><ul><li>An awaited task is a process that executes some function, sends the function result back to the starter process, and then terminates</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>&gt; long_job <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  fn -&gt;
</span></span><span style=display:flex><span>    Process.sleep<span style=color:#f92672>(</span>2000<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    :some_result
</span></span><span style=display:flex><span>  end
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>&gt; task <span style=color:#f92672>=</span> Task.async<span style=color:#f92672>(</span>long_job<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># await will wait response from the task process</span>
</span></span><span style=display:flex><span><span style=color:#75715e># default 5 seconds to timeout</span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>&gt; Task.await<span style=color:#f92672>(</span>task<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>:some_result
</span></span></code></pre></div><pre><code>+ if any task process crashes, the starter process will crash too

+ `Task.async/1` has all-or-nothing semantics
</code></pre><ul><li>Non-awaited tasks</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>&gt; Task.start_link<span style=color:#f92672>(</span>fn -&gt;
</span></span><span style=display:flex><span>  Process.sleep<span style=color:#f92672>(</span>1000<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  IO.puts<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Hello from task&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>end<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>:ok, <span style=color:#75715e>#PID&lt;0.89.0&gt;} # Result of Task.start_link/1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Hello from task! <span style=color:#75715e># Printed 1 second later</span>
</span></span></code></pre></div><ul><li>Supervising dynamic tasks</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>&gt; Task.Supervisor.start_link<span style=color:#f92672>(</span>name: MyTaskSupervisor<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>&gt; Task.Supervisor.start_child<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>  MyTaskSupervisor,
</span></span><span style=display:flex><span>  fn -&gt;
</span></span><span style=display:flex><span>    IO.puts<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Task started&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Process.sleep<span style=color:#f92672>(</span>2000<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    IO.puts<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Task stopping&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  end
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>:ok, <span style=color:#75715e>#PID&lt;0.118.0&gt;}</span>
</span></span><span style=display:flex><span>Task started
</span></span><span style=display:flex><span>Task stopping
</span></span></code></pre></div><p>Agents</p><ul><li><p>provides an abstraction that’s similar to <code>GenServer</code></p></li><li><p>require a bit less ceremony and can, therefore, eliminate some boilerplate associated with <code>GenServer</code></p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>&gt; <span style=color:#f92672>{</span>:ok, pid<span style=color:#f92672>}</span> <span style=color:#f92672>=</span> Agent.start_link<span style=color:#f92672>(</span>fn -&gt; %<span style=color:#f92672>{</span>name: <span style=color:#e6db74>&#34;Bob&#34;</span>, age: 30<span style=color:#f92672>}</span> end<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>:ok, <span style=color:#75715e>#PID&lt;0.86.0&gt;}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>&gt; Agent.get<span style=color:#f92672>(</span>pid, fn state -&gt; state.name end<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Bob&#34;</span>
</span></span></code></pre></div><pre><code>+ execute passed lambda
</code></pre><ul><li><p>Limitations of agents</p><ul><li><p>cannot handle plain messages</p></li><li><p>cannot run some logic on termination</p></li></ul></li></ul><p>ETS tables</p><ul><li><p>ETS (Erlang Term Storage) tables are a mechanism that allows you to share some state between multiple processes in a more efficient way</p></li><li><p>usecase</p><ul><li>shared key–value structures and counters</li></ul></li><li><p>ETS characteristics</p><ul><li><p>There’s no specific ETS data type. A table is identified by its ID (a reference
type) or a global name (an atom).</p></li><li><p>ETS tables are mutable. A write to a table will affect subsequent read operations.</p></li><li><p>Multiple processes can write to or read from a single ETS table. Writes and
reads might be performed simultaneously.</p></li><li><p>Minimum concurrency safety is ensured. Multiple processes can safely write to the same row of the same table. The last write wins.</p></li><li><p>An ETS table resides in a separate memory space. Any data coming in or out is deep copied.</p></li><li><p>ETS doesn’t put pressure on the garbage collector. Overwritten or deleted data is immediately released.</p></li><li><p>An ETS table is deeply connected to its owner process (by default, the process that created the table). If the owner process terminates, the ETS table is reclaimed.</p></li><li><p>Other than on owner-process termination, there’s no automatic garbage collection of an ETS table. Even if you don’t hold a reference to the table, it still occupies memory.</p></li></ul></li></ul><pre tabindex=0><code>iex(1)&gt; table = :ets.new(:my_table, [])
#Reference&lt;0.970221231.4117102596.53103&gt;

iex(2)&gt; :ets.insert(table, {:key_1, 1})
true

iex(3)&gt; :ets.insert(table, {:key_2, 2})
true

iex(5)&gt; :ets.lookup(table, :key_1)
[key_1: 3]
</code></pre><ul><li><p>table types</p><ul><li><p><code>:set</code>—This is the default. One row per distinct key is allowed</p></li><li><p><code>:ordered_set</code>—This is just like :set, but rows are in term order (comparison via the &lt; and > operators)</p></li><li><p><code>:bag</code>—Multiple rows with the same key are allowed, but two rows can’t be completely identical</p></li><li><p><code>:duplicate_bag</code>—This is just like <code>:bag,</code> but it allows duplicate rows</p></li></ul></li><li><p>table permissions</p><ul><li><p><code>:protected</code>—This is the default. The owner process can read from and write to the table. All other processes can read from the table</p></li><li><p><code>:public</code>—All processes can read from and write to the table</p></li><li><p><code>:private</code>—Only the owner process can access the table</p></li></ul></li><li><p>full-blown match specification</p><ul><li><p><code>:ets.select/2</code></p><ul><li><p><a href=https://erlang.org/doc/man/ets.html#select-2>https://erlang.org/doc/man/ets.html#select-2</a></p></li><li><p>make task simpler</p><ul><li><p><code>ex2ms</code></p><ul><li><a href=https://github.com/ericmj/ex2ms>https://github.com/ericmj/ex2ms</a></li></ul></li></ul></li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://al002.github.io/>Elixir in action notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>