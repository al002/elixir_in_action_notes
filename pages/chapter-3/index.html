<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Chapter 3 | Elixir in action notes</title>
<meta name=keywords content><meta name=description content='Pattern matching


= operator is called the match operator

assignment-like expression is an example of pattern matching



iex(1)> person = {"Bob", 25}
+ Matching tuples

iex(1)> {name, age} = {"Bob", 25}
+ Matching constants

iex(2)> person = {:person, "Bob", 25}

iex(3)> {:person, name, age} = person
{:person, "Bob", 25}

{:ok, contents} = File.read("my_app.config")
  + By using constants in patterns, you tighten the match, ensuring some part of the right side has a specific value.

  + `^` pin operator

iex(7)> expected_name = "Bob"
"Bob"
iex(8)> {^expected_name, _} = {"Bob", 25}
{"Bob", 25}
iex(9)> {^expected_name, _} = {"Alice", 30}
** (MatchError) no match of right hand side value: {"Alice", 30}
    + Using `^expected_name` in patterns indicates you expect the value of the variable `expected_name` to be in the appropriate position in the right-side term

      + like `({"Bob", _} = …)`

+ Matching lists

iex(1)> [first, second, third] = [1, 2, 3]
[1, 2, 3]


iex(3)> [head | tail] = [1, 2, 3]
[1, 2, 3]

iex(4)> head
1

iex(5)> tail
[2, 3]
+ Matching maps

iex(1)> %{name: name, age: age} = %{name: "Bob", age: 25}
%{age: 25, name: "Bob"}

iex(6)> %{age: age, works_at: works_at} = %{name: "Bob", age: 25}
** (MatchError) no match of right hand side value
+ Matching bitstrings and binaries

iex(6)> <<b1, rest :: binary>> = binary
<<1, 2, 3>>

iex(7)> b1
1

iex(8)> rest
<<2, 3>>
+ Matching binary strings

iex(16)> command = "ping www.example.com"
"ping www.example.com"

iex(17)> "ping " <> url = command
"ping www.example.com"

iex(18)> url
"www.example.com"
+ Compound matches


  + match expression


    + `pattern = expression`

    + `iex(2)> a = 1 + 3`

      + 1 The expression on the right side is evaluated.

      + 2 The resulting value is matched against the left-side pattern.

      + 3 Variables from the pattern are bound.

      + 4 The result of the match expression is the result of the right-side term

    + match chaining

iex(3)> a = (b = 1 + 3)
4

iex(4)> a =b=1+3
4
      + 1 The expression 1 + 3 is evaluated.

      + 2 The result (4) is matched against the pattern b.

      + 3 The result of the inner match (which is, again, 4) is matched against the pattern a.

iex(6)> date_time = {_, {hour, _, _}} = :calendar.local_time()

iex(7)> {_, {hour, _, _}} = date_time = :calendar.local_time()

iex(8)> date_time
{{2023, 11, 11}, {21, 32, 34}}

iex(9)> hour
21
      + ordering is not matter

        + because the result of a pattern match is always the result of the term being matched (whatever is on the right side of the match operator)

+ General behavior


  + two parts:

    + *pattern* (left side)

    + *term* (right side)

  + You assert your expectations about the right-side term. If these expectations aren’t met, an error is raised.

  + You bind some parts of the term to variables from the pattern.


Matching with functions

def my_fun(arg1, arg2) do
	...
end
+ `arg1` and `arg2` are patterns

+ the arguments you provide are matched against the patterns specified in the function definition

+ Multiclause functions


  + A clause is a function definition specified by the def expression

defmodule Geometry do
  def area({:rectangle, a, b}) do
    a*b
  end

  def area({:square, a}) do
  	a*a
  end
  
  def area({:circle, r}) do
  	r * r * 3.14
  end
end
  + clause order is matter, the runtime tries to select the clauses, using the order in the source code

+ Guards


  + The guard is a logical expression that adds further conditions to the pattern

defmodule TestNum do
  def test(x) when x < 0 do
  	:negative
  end
  
  def test(x) when x == 0 do
  	:zero
  end
  
  def test(x) when x > 0 do
  	:positive
  end
end
  + operators and functions allowed in guards

    + Comparison operators (=\=, !=, =\
    , !
, >, <, <=, and >=)

    + Boolean operators (and and or) and negation operators (not and !)

    + Arithmetic operators (+, -, *, and /)

    + Type-check functions from the Kernel module (e.g., is_number/1, is_atom/1, and so on)

    + https://hexdocs.pm/elixir/patterns-and-guards.html#guards

  + when error raised inside guard, it won&#39;t propagate, guard expression will return `false`. The corresponding clause won’t match, but some other clause might

+ Multiclause lambdas


  + general lambda syntax

fn
  pattern_1, pattern_2 ->
  	...
  pattern_3, pattern_4 ->
  	...
  ...
end
iex(3)> test_num =
fn
  x when is_number(x) and x < 0 -> :negative
  x when x == 0 -> :zero
  x when is_number(x) and x > 0 -> :positive
end


Conditionals'><meta name=author content><link rel=canonical href=https://al002.github.io/pages/chapter-3/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://al002.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://al002.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://al002.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://al002.github.io/apple-touch-icon.png><link rel=mask-icon href=https://al002.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://al002.github.io/pages/chapter-3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Chapter 3"><meta property="og:description" content='Pattern matching


= operator is called the match operator

assignment-like expression is an example of pattern matching



iex(1)> person = {"Bob", 25}
+ Matching tuples

iex(1)> {name, age} = {"Bob", 25}
+ Matching constants

iex(2)> person = {:person, "Bob", 25}

iex(3)> {:person, name, age} = person
{:person, "Bob", 25}

{:ok, contents} = File.read("my_app.config")
  + By using constants in patterns, you tighten the match, ensuring some part of the right side has a specific value.

  + `^` pin operator

iex(7)> expected_name = "Bob"
"Bob"
iex(8)> {^expected_name, _} = {"Bob", 25}
{"Bob", 25}
iex(9)> {^expected_name, _} = {"Alice", 30}
** (MatchError) no match of right hand side value: {"Alice", 30}
    + Using `^expected_name` in patterns indicates you expect the value of the variable `expected_name` to be in the appropriate position in the right-side term

      + like `({"Bob", _} = …)`

+ Matching lists

iex(1)> [first, second, third] = [1, 2, 3]
[1, 2, 3]


iex(3)> [head | tail] = [1, 2, 3]
[1, 2, 3]

iex(4)> head
1

iex(5)> tail
[2, 3]
+ Matching maps

iex(1)> %{name: name, age: age} = %{name: "Bob", age: 25}
%{age: 25, name: "Bob"}

iex(6)> %{age: age, works_at: works_at} = %{name: "Bob", age: 25}
** (MatchError) no match of right hand side value
+ Matching bitstrings and binaries

iex(6)> <<b1, rest :: binary>> = binary
<<1, 2, 3>>

iex(7)> b1
1

iex(8)> rest
<<2, 3>>
+ Matching binary strings

iex(16)> command = "ping www.example.com"
"ping www.example.com"

iex(17)> "ping " <> url = command
"ping www.example.com"

iex(18)> url
"www.example.com"
+ Compound matches


  + match expression


    + `pattern = expression`

    + `iex(2)> a = 1 + 3`

      + 1 The expression on the right side is evaluated.

      + 2 The resulting value is matched against the left-side pattern.

      + 3 Variables from the pattern are bound.

      + 4 The result of the match expression is the result of the right-side term

    + match chaining

iex(3)> a = (b = 1 + 3)
4

iex(4)> a =b=1+3
4
      + 1 The expression 1 + 3 is evaluated.

      + 2 The result (4) is matched against the pattern b.

      + 3 The result of the inner match (which is, again, 4) is matched against the pattern a.

iex(6)> date_time = {_, {hour, _, _}} = :calendar.local_time()

iex(7)> {_, {hour, _, _}} = date_time = :calendar.local_time()

iex(8)> date_time
{{2023, 11, 11}, {21, 32, 34}}

iex(9)> hour
21
      + ordering is not matter

        + because the result of a pattern match is always the result of the term being matched (whatever is on the right side of the match operator)

+ General behavior


  + two parts:

    + *pattern* (left side)

    + *term* (right side)

  + You assert your expectations about the right-side term. If these expectations aren’t met, an error is raised.

  + You bind some parts of the term to variables from the pattern.


Matching with functions

def my_fun(arg1, arg2) do
	...
end
+ `arg1` and `arg2` are patterns

+ the arguments you provide are matched against the patterns specified in the function definition

+ Multiclause functions


  + A clause is a function definition specified by the def expression

defmodule Geometry do
  def area({:rectangle, a, b}) do
    a*b
  end

  def area({:square, a}) do
  	a*a
  end
  
  def area({:circle, r}) do
  	r * r * 3.14
  end
end
  + clause order is matter, the runtime tries to select the clauses, using the order in the source code

+ Guards


  + The guard is a logical expression that adds further conditions to the pattern

defmodule TestNum do
  def test(x) when x < 0 do
  	:negative
  end
  
  def test(x) when x == 0 do
  	:zero
  end
  
  def test(x) when x > 0 do
  	:positive
  end
end
  + operators and functions allowed in guards

    + Comparison operators (=\=, !=, =\
    , !
, >, <, <=, and >=)

    + Boolean operators (and and or) and negation operators (not and !)

    + Arithmetic operators (+, -, *, and /)

    + Type-check functions from the Kernel module (e.g., is_number/1, is_atom/1, and so on)

    + https://hexdocs.pm/elixir/patterns-and-guards.html#guards

  + when error raised inside guard, it won&#39;t propagate, guard expression will return `false`. The corresponding clause won’t match, but some other clause might

+ Multiclause lambdas


  + general lambda syntax

fn
  pattern_1, pattern_2 ->
  	...
  pattern_3, pattern_4 ->
  	...
  ...
end
iex(3)> test_num =
fn
  x when is_number(x) and x < 0 -> :negative
  x when x == 0 -> :zero
  x when is_number(x) and x > 0 -> :positive
end


Conditionals'><meta property="og:type" content="article"><meta property="og:url" content="https://al002.github.io/pages/chapter-3/"><meta property="article:section" content="pages"><meta property="article:published_time" content="2025-01-03T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Chapter 3"><meta name=twitter:description content='Pattern matching


= operator is called the match operator

assignment-like expression is an example of pattern matching



iex(1)> person = {"Bob", 25}
+ Matching tuples

iex(1)> {name, age} = {"Bob", 25}
+ Matching constants

iex(2)> person = {:person, "Bob", 25}

iex(3)> {:person, name, age} = person
{:person, "Bob", 25}

{:ok, contents} = File.read("my_app.config")
  + By using constants in patterns, you tighten the match, ensuring some part of the right side has a specific value.

  + `^` pin operator

iex(7)> expected_name = "Bob"
"Bob"
iex(8)> {^expected_name, _} = {"Bob", 25}
{"Bob", 25}
iex(9)> {^expected_name, _} = {"Alice", 30}
** (MatchError) no match of right hand side value: {"Alice", 30}
    + Using `^expected_name` in patterns indicates you expect the value of the variable `expected_name` to be in the appropriate position in the right-side term

      + like `({"Bob", _} = …)`

+ Matching lists

iex(1)> [first, second, third] = [1, 2, 3]
[1, 2, 3]


iex(3)> [head | tail] = [1, 2, 3]
[1, 2, 3]

iex(4)> head
1

iex(5)> tail
[2, 3]
+ Matching maps

iex(1)> %{name: name, age: age} = %{name: "Bob", age: 25}
%{age: 25, name: "Bob"}

iex(6)> %{age: age, works_at: works_at} = %{name: "Bob", age: 25}
** (MatchError) no match of right hand side value
+ Matching bitstrings and binaries

iex(6)> <<b1, rest :: binary>> = binary
<<1, 2, 3>>

iex(7)> b1
1

iex(8)> rest
<<2, 3>>
+ Matching binary strings

iex(16)> command = "ping www.example.com"
"ping www.example.com"

iex(17)> "ping " <> url = command
"ping www.example.com"

iex(18)> url
"www.example.com"
+ Compound matches


  + match expression


    + `pattern = expression`

    + `iex(2)> a = 1 + 3`

      + 1 The expression on the right side is evaluated.

      + 2 The resulting value is matched against the left-side pattern.

      + 3 Variables from the pattern are bound.

      + 4 The result of the match expression is the result of the right-side term

    + match chaining

iex(3)> a = (b = 1 + 3)
4

iex(4)> a =b=1+3
4
      + 1 The expression 1 + 3 is evaluated.

      + 2 The result (4) is matched against the pattern b.

      + 3 The result of the inner match (which is, again, 4) is matched against the pattern a.

iex(6)> date_time = {_, {hour, _, _}} = :calendar.local_time()

iex(7)> {_, {hour, _, _}} = date_time = :calendar.local_time()

iex(8)> date_time
{{2023, 11, 11}, {21, 32, 34}}

iex(9)> hour
21
      + ordering is not matter

        + because the result of a pattern match is always the result of the term being matched (whatever is on the right side of the match operator)

+ General behavior


  + two parts:

    + *pattern* (left side)

    + *term* (right side)

  + You assert your expectations about the right-side term. If these expectations aren’t met, an error is raised.

  + You bind some parts of the term to variables from the pattern.


Matching with functions

def my_fun(arg1, arg2) do
	...
end
+ `arg1` and `arg2` are patterns

+ the arguments you provide are matched against the patterns specified in the function definition

+ Multiclause functions


  + A clause is a function definition specified by the def expression

defmodule Geometry do
  def area({:rectangle, a, b}) do
    a*b
  end

  def area({:square, a}) do
  	a*a
  end
  
  def area({:circle, r}) do
  	r * r * 3.14
  end
end
  + clause order is matter, the runtime tries to select the clauses, using the order in the source code

+ Guards


  + The guard is a logical expression that adds further conditions to the pattern

defmodule TestNum do
  def test(x) when x < 0 do
  	:negative
  end
  
  def test(x) when x == 0 do
  	:zero
  end
  
  def test(x) when x > 0 do
  	:positive
  end
end
  + operators and functions allowed in guards

    + Comparison operators (=\=, !=, =\
    , !
, >, <, <=, and >=)

    + Boolean operators (and and or) and negation operators (not and !)

    + Arithmetic operators (+, -, *, and /)

    + Type-check functions from the Kernel module (e.g., is_number/1, is_atom/1, and so on)

    + https://hexdocs.pm/elixir/patterns-and-guards.html#guards

  + when error raised inside guard, it won&#39;t propagate, guard expression will return `false`. The corresponding clause won’t match, but some other clause might

+ Multiclause lambdas


  + general lambda syntax

fn
  pattern_1, pattern_2 ->
  	...
  pattern_3, pattern_4 ->
  	...
  ...
end
iex(3)> test_num =
fn
  x when is_number(x) and x < 0 -> :negative
  x when x == 0 -> :zero
  x when is_number(x) and x > 0 -> :positive
end


Conditionals'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Pages","item":"https://al002.github.io/pages/"},{"@type":"ListItem","position":2,"name":"Chapter 3","item":"https://al002.github.io/pages/chapter-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Chapter 3","name":"Chapter 3","description":"Pattern matching\n= operator is called the match operator\nassignment-like expression is an example of pattern matching iex(1)\u0026gt; person = {\u0026#34;Bob\u0026#34;, 25} + Matching tuples iex(1)\u0026gt; {name, age} = {\u0026#34;Bob\u0026#34;, 25} + Matching constants iex(2)\u0026gt; person = {:person, \u0026#34;Bob\u0026#34;, 25} iex(3)\u0026gt; {:person, name, age} = person {:person, \u0026#34;Bob\u0026#34;, 25} {:ok, contents} = File.read(\u0026#34;my_app.config\u0026#34;) + By using constants in patterns, you tighten the match, ensuring some part of the right side has a specific value. + `^` pin operator iex(7)\u0026gt; expected_name = \u0026#34;Bob\u0026#34; \u0026#34;Bob\u0026#34; iex(8)\u0026gt; {^expected_name, _} = {\u0026#34;Bob\u0026#34;, 25} {\u0026#34;Bob\u0026#34;, 25} iex(9)\u0026gt; {^expected_name, _} = {\u0026#34;Alice\u0026#34;, 30} ** (MatchError) no match of right hand side value: {\u0026#34;Alice\u0026#34;, 30} + Using `^expected_name` in patterns indicates you expect the value of the variable `expected_name` to be in the appropriate position in the right-side term + like `({\u0026quot;Bob\u0026quot;, _} = …)` + Matching lists iex(1)\u0026gt; [first, second, third] = [1, 2, 3] [1, 2, 3] iex(3)\u0026gt; [head | tail] = [1, 2, 3] [1, 2, 3] iex(4)\u0026gt; head 1 iex(5)\u0026gt; tail [2, 3] + Matching maps iex(1)\u0026gt; %{name: name, age: age} = %{name: \u0026#34;Bob\u0026#34;, age: 25} %{age: 25, name: \u0026#34;Bob\u0026#34;} iex(6)\u0026gt; %{age: age, works_at: works_at} = %{name: \u0026#34;Bob\u0026#34;, age: 25} ** (MatchError) no match of right hand side value + Matching bitstrings and binaries iex(6)\u0026gt; \u0026lt;\u0026lt;b1, rest :: binary\u0026gt;\u0026gt; = binary \u0026lt;\u0026lt;1, 2, 3\u0026gt;\u0026gt; iex(7)\u0026gt; b1 1 iex(8)\u0026gt; rest \u0026lt;\u0026lt;2, 3\u0026gt;\u0026gt; + Matching binary strings iex(16)\u0026gt; command = \u0026#34;ping www.example.com\u0026#34; \u0026#34;ping www.example.com\u0026#34; iex(17)\u0026gt; \u0026#34;ping \u0026#34; \u0026lt;\u0026gt; url = command \u0026#34;ping www.example.com\u0026#34; iex(18)\u0026gt; url \u0026#34;www.example.com\u0026#34; + Compound matches + match expression + `pattern = expression` + `iex(2)\u0026gt; a = 1 + 3` + 1 The expression on the right side is evaluated. + 2 The resulting value is matched against the left-side pattern. + 3 Variables from the pattern are bound. + 4 The result of the match expression is the result of the right-side term + match chaining iex(3)\u0026gt; a = (b = 1 + 3) 4 iex(4)\u0026gt; a =b=1+3 4 + 1 The expression 1 + 3 is evaluated. + 2 The result (4) is matched against the pattern b. + 3 The result of the inner match (which is, again, 4) is matched against the pattern a. iex(6)\u0026gt; date_time = {_, {hour, _, _}} = :calendar.local_time() iex(7)\u0026gt; {_, {hour, _, _}} = date_time = :calendar.local_time() iex(8)\u0026gt; date_time {{2023, 11, 11}, {21, 32, 34}} iex(9)\u0026gt; hour 21 + ordering is not matter + because the result of a pattern match is always the result of the term being matched (whatever is on the right side of the match operator) + General behavior + two parts: + *pattern* (left side) + *term* (right side) + You assert your expectations about the right-side term. If these expectations aren’t met, an error is raised. + You bind some parts of the term to variables from the pattern. Matching with functions def my_fun(arg1, arg2) do ... end + `arg1` and `arg2` are patterns + the arguments you provide are matched against the patterns specified in the function definition + Multiclause functions + A clause is a function definition specified by the def expression defmodule Geometry do def area({:rectangle, a, b}) do a*b end def area({:square, a}) do a*a end def area({:circle, r}) do r * r * 3.14 end end + clause order is matter, the runtime tries to select the clauses, using the order in the source code + Guards + The guard is a logical expression that adds further conditions to the pattern defmodule TestNum do def test(x) when x \u0026lt; 0 do :negative end def test(x) when x == 0 do :zero end def test(x) when x \u0026gt; 0 do :positive end end + operators and functions allowed in guards + Comparison operators (=\\=, !=, =\\ , ! , \u0026gt;, \u0026lt;, \u0026lt;=, and \u0026gt;=) + Boolean operators (and and or) and negation operators (not and !) + Arithmetic operators (+, -, *, and /) + Type-check functions from the Kernel module (e.g., is_number/1, is_atom/1, and so on) + https://hexdocs.pm/elixir/patterns-and-guards.html#guards + when error raised inside guard, it won't propagate, guard expression will return `false`. The corresponding clause won’t match, but some other clause might + Multiclause lambdas + general lambda syntax fn pattern_1, pattern_2 -\u0026gt; ... pattern_3, pattern_4 -\u0026gt; ... ... end iex(3)\u0026gt; test_num = fn x when is_number(x) and x \u0026lt; 0 -\u0026gt; :negative x when x == 0 -\u0026gt; :zero x when is_number(x) and x \u0026gt; 0 -\u0026gt; :positive end Conditionals\n","keywords":[],"articleBody":"Pattern matching\n= operator is called the match operator\nassignment-like expression is an example of pattern matching iex(1)\u003e person = {\"Bob\", 25} + Matching tuples iex(1)\u003e {name, age} = {\"Bob\", 25} + Matching constants iex(2)\u003e person = {:person, \"Bob\", 25} iex(3)\u003e {:person, name, age} = person {:person, \"Bob\", 25} {:ok, contents} = File.read(\"my_app.config\") + By using constants in patterns, you tighten the match, ensuring some part of the right side has a specific value. + `^` pin operator iex(7)\u003e expected_name = \"Bob\" \"Bob\" iex(8)\u003e {^expected_name, _} = {\"Bob\", 25} {\"Bob\", 25} iex(9)\u003e {^expected_name, _} = {\"Alice\", 30} ** (MatchError) no match of right hand side value: {\"Alice\", 30} + Using `^expected_name` in patterns indicates you expect the value of the variable `expected_name` to be in the appropriate position in the right-side term + like `({\"Bob\", _} = …)` + Matching lists iex(1)\u003e [first, second, third] = [1, 2, 3] [1, 2, 3] iex(3)\u003e [head | tail] = [1, 2, 3] [1, 2, 3] iex(4)\u003e head 1 iex(5)\u003e tail [2, 3] + Matching maps iex(1)\u003e %{name: name, age: age} = %{name: \"Bob\", age: 25} %{age: 25, name: \"Bob\"} iex(6)\u003e %{age: age, works_at: works_at} = %{name: \"Bob\", age: 25} ** (MatchError) no match of right hand side value + Matching bitstrings and binaries iex(6)\u003e \u003c\u003e = binary \u003c\u003c1, 2, 3\u003e\u003e iex(7)\u003e b1 1 iex(8)\u003e rest \u003c\u003c2, 3\u003e\u003e + Matching binary strings iex(16)\u003e command = \"ping www.example.com\" \"ping www.example.com\" iex(17)\u003e \"ping \" \u003c\u003e url = command \"ping www.example.com\" iex(18)\u003e url \"www.example.com\" + Compound matches + match expression + `pattern = expression` + `iex(2)\u003e a = 1 + 3` + 1 The expression on the right side is evaluated. + 2 The resulting value is matched against the left-side pattern. + 3 Variables from the pattern are bound. + 4 The result of the match expression is the result of the right-side term + match chaining iex(3)\u003e a = (b = 1 + 3) 4 iex(4)\u003e a =b=1+3 4 + 1 The expression 1 + 3 is evaluated. + 2 The result (4) is matched against the pattern b. + 3 The result of the inner match (which is, again, 4) is matched against the pattern a. iex(6)\u003e date_time = {_, {hour, _, _}} = :calendar.local_time() iex(7)\u003e {_, {hour, _, _}} = date_time = :calendar.local_time() iex(8)\u003e date_time {{2023, 11, 11}, {21, 32, 34}} iex(9)\u003e hour 21 + ordering is not matter + because the result of a pattern match is always the result of the term being matched (whatever is on the right side of the match operator) + General behavior + two parts: + *pattern* (left side) + *term* (right side) + You assert your expectations about the right-side term. If these expectations aren’t met, an error is raised. + You bind some parts of the term to variables from the pattern. Matching with functions def my_fun(arg1, arg2) do ... end + `arg1` and `arg2` are patterns + the arguments you provide are matched against the patterns specified in the function definition + Multiclause functions + A clause is a function definition specified by the def expression defmodule Geometry do def area({:rectangle, a, b}) do a*b end def area({:square, a}) do a*a end def area({:circle, r}) do r * r * 3.14 end end + clause order is matter, the runtime tries to select the clauses, using the order in the source code + Guards + The guard is a logical expression that adds further conditions to the pattern defmodule TestNum do def test(x) when x \u003c 0 do :negative end def test(x) when x == 0 do :zero end def test(x) when x \u003e 0 do :positive end end + operators and functions allowed in guards + Comparison operators (=\\=, !=, =\\ , ! , \u003e, \u003c, \u003c=, and \u003e=) + Boolean operators (and and or) and negation operators (not and !) + Arithmetic operators (+, -, *, and /) + Type-check functions from the Kernel module (e.g., is_number/1, is_atom/1, and so on) + https://hexdocs.pm/elixir/patterns-and-guards.html#guards + when error raised inside guard, it won't propagate, guard expression will return `false`. The corresponding clause won’t match, but some other clause might + Multiclause lambdas + general lambda syntax fn pattern_1, pattern_2 -\u003e ... pattern_3, pattern_4 -\u003e ... ... end iex(3)\u003e test_num = fn x when is_number(x) and x \u003c 0 -\u003e :negative x when x == 0 -\u003e :zero x when is_number(x) and x \u003e 0 -\u003e :positive end Conditionals\nBranching with multiclause functions iex(1)\u003e defmodule Polymorphic do def double(x) when is_number(x), do: 2 * x def double(x) when is_binary(x), do: x \u003c\u003e x end iex(2)\u003e Polymorphic.double(3) 6 iex(3)\u003e Polymorphic.double(\"Jar\") \"JarJar\" + Classical branching expressions + if and unless if condition do ... else ... end if condition, do: something, else: another_thing unless result == :error, do: send_notification(...) + cond cond do expression_1 -\u003e ... expression_2 -\u003e ... ... end + case case expression do pattern_1 -\u003e ... pattern_2 -\u003e ... ... end + no differences between case and multiclause functions + The with expression def extract_user(user) do case extract_login(user) do {:error, reason} -\u003e {:error, reason} {:ok, login} -\u003e case extract_email(user) do {:error, reason} -\u003e {:error, reason} {:ok, email} -\u003e case extract_password(user) do {:error, reason} -\u003e {:error, reason} {:ok, password} -\u003e %{login: login, email: email, password: password} end end end end def extract_user(user) do with {:ok, login} \u003c- extract_login(user), {:ok, email} \u003c- extract_email(user), {:ok, password} \u003c- extract_password(user) do {:ok, %{login: login, email: email, password: password}} end end Loops and iterations\nThe principal looping tool in Elixir is recursion defmodule ListHelper do def sum([]), do: 0 def sum([head | tail]) do head + sum(tail) end end + Tail function calls + If the last thing a function does is call another function (or itself), you’re dealing with a tail call def original_fun(...) do ... another_fun(...) end defmodule ListHelper do def sum(list) do do_sum(0, list) end defp do_sum(current_sum, []) do current_sum end defp do_sum(current_sum, [head | tail]) do new_sum = head + current_sum do_sum(new_sum, tail) end end + Recognizing tail calls def fun(...) do ... if something do ... another_fun(...) # Tail call end end def fun(...) do 1 + another_fun(...) # Not a tail call end + After another_fun finishes, you must increment its result by 1 to compute the final result of fun + https://github.com/sasa1977/elixir-in-action/blob/3rd-edition/code_samples/ch03/recursion_practice_tc.ex + Higher-order functions + A higher-order function is a type of function that takes one or more functions as its input or returns one or more functions (or both) iex(1)\u003e Enum.each( [1, 2, 3], fn x -\u003e IO.puts(x) end ) 1 2 3 + Comprehensions iex(4)\u003e multiplication_table = for x \u003c- 1..9, y \u003c- 1..9, into: %{} do {{x, y}, x*y} end + Streams + A stream is a special kind of enumerable that can be useful for doing lazy composable operations over anything enumerable iex(7)\u003e employees |\u003e Stream.with_index() |\u003e Enum.each(fn {employee, index} -\u003e IO.puts(\"#{index + 1}. #{employee}\") end) ","wordCount":"1143","inLanguage":"en","datePublished":"2025-01-03T00:00:00Z","dateModified":"2025-01-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://al002.github.io/pages/chapter-3/"},"publisher":{"@type":"Organization","name":"Elixir in action notes","logo":{"@type":"ImageObject","url":"https://al002.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://al002.github.io/ accesskey=h title="Elixir in action notes (Alt + H)">Elixir in action notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Chapter 3</h1><div class=post-meta><span title='2025-01-03 00:00:00 +0000 UTC'>January 3, 2025</span></div></header><div class=post-content><p>Pattern matching</p><ul><li><p><code>=</code> operator is called the match operator</p><ul><li>assignment-like expression is an example of <em>pattern matching</em></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>&gt; person <span style=color:#f92672>=</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;Bob&#34;</span>, 25<span style=color:#f92672>}</span>
</span></span></code></pre></div><pre><code>+ Matching tuples
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>&gt; <span style=color:#f92672>{</span>name, age<span style=color:#f92672>}</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;Bob&#34;</span>, 25<span style=color:#f92672>}</span>
</span></span></code></pre></div><pre><code>+ Matching constants
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>&gt; person <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>:person, <span style=color:#e6db74>&#34;Bob&#34;</span>, 25<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>&gt; <span style=color:#f92672>{</span>:person, name, age<span style=color:#f92672>}</span> <span style=color:#f92672>=</span> person
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>:person, <span style=color:#e6db74>&#34;Bob&#34;</span>, 25<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>:ok, contents<span style=color:#f92672>}</span> <span style=color:#f92672>=</span> File.read<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;my_app.config&#34;</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><pre><code>  + By using constants in patterns, you tighten the match, ensuring some part of the right side has a specific value.

  + `^` pin operator
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>7<span style=color:#f92672>)</span>&gt; expected_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Bob&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Bob&#34;</span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>8<span style=color:#f92672>)</span>&gt; <span style=color:#f92672>{</span>^expected_name, _<span style=color:#f92672>}</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;Bob&#34;</span>, 25<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;Bob&#34;</span>, 25<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>9<span style=color:#f92672>)</span>&gt; <span style=color:#f92672>{</span>^expected_name, _<span style=color:#f92672>}</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;Alice&#34;</span>, 30<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>** <span style=color:#f92672>(</span>MatchError<span style=color:#f92672>)</span> no match of right hand side value: <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;Alice&#34;</span>, 30<span style=color:#f92672>}</span>
</span></span></code></pre></div><pre><code>    + Using `^expected_name` in patterns indicates you expect the value of the variable `expected_name` to be in the appropriate position in the right-side term

      + like `({&quot;Bob&quot;, _} = …)`

+ Matching lists
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>&gt; <span style=color:#f92672>[</span>first, second, third<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>1, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>&gt; <span style=color:#f92672>[</span>head | tail<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>1, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1, 2, 3<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>4<span style=color:#f92672>)</span>&gt; head
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>5<span style=color:#f92672>)</span>&gt; tail
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>2, 3<span style=color:#f92672>]</span>
</span></span></code></pre></div><pre><code>+ Matching maps
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>&gt; %<span style=color:#f92672>{</span>name: name, age: age<span style=color:#f92672>}</span> <span style=color:#f92672>=</span> %<span style=color:#f92672>{</span>name: <span style=color:#e6db74>&#34;Bob&#34;</span>, age: 25<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>%<span style=color:#f92672>{</span>age: 25, name: <span style=color:#e6db74>&#34;Bob&#34;</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>6<span style=color:#f92672>)</span>&gt; %<span style=color:#f92672>{</span>age: age, works_at: works_at<span style=color:#f92672>}</span> <span style=color:#f92672>=</span> %<span style=color:#f92672>{</span>name: <span style=color:#e6db74>&#34;Bob&#34;</span>, age: 25<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>** <span style=color:#f92672>(</span>MatchError<span style=color:#f92672>)</span> no match of right hand side value
</span></span></code></pre></div><pre><code>+ Matching bitstrings and binaries
</code></pre><pre tabindex=0><code class=language-bahs data-lang=bahs>iex(6)&gt; &lt;&lt;b1, rest :: binary&gt;&gt; = binary
&lt;&lt;1, 2, 3&gt;&gt;

iex(7)&gt; b1
1

iex(8)&gt; rest
&lt;&lt;2, 3&gt;&gt;
</code></pre><pre><code>+ Matching binary strings
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>16<span style=color:#f92672>)</span>&gt; command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ping www.example.com&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;ping www.example.com&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>17<span style=color:#f92672>)</span>&gt; <span style=color:#e6db74>&#34;ping &#34;</span> &lt;&gt; url <span style=color:#f92672>=</span> command
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;ping www.example.com&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>18<span style=color:#f92672>)</span>&gt; url
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;www.example.com&#34;</span>
</span></span></code></pre></div><pre><code>+ Compound matches


  + match expression


    + `pattern = expression`

    + `iex(2)&gt; a = 1 + 3`

      + 1 The expression on the right side is evaluated.

      + 2 The resulting value is matched against the left-side pattern.

      + 3 Variables from the pattern are bound.

      + 4 The result of the match expression is the result of the right-side term

    + match chaining
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>&gt; a <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>b <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> + 3<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>4<span style=color:#f92672>)</span>&gt; a <span style=color:#f92672>=</span>b<span style=color:#f92672>=</span>1+3
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>
</span></span></code></pre></div><pre><code>      + 1 The expression 1 + 3 is evaluated.

      + 2 The result (4) is matched against the pattern b.

      + 3 The result of the inner match (which is, again, 4) is matched against the pattern a.
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>6<span style=color:#f92672>)</span>&gt; date_time <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>_, <span style=color:#f92672>{</span>hour, _, _<span style=color:#f92672>}}</span> <span style=color:#f92672>=</span> :calendar.local_time<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>7<span style=color:#f92672>)</span>&gt; <span style=color:#f92672>{</span>_, <span style=color:#f92672>{</span>hour, _, _<span style=color:#f92672>}}</span> <span style=color:#f92672>=</span> date_time <span style=color:#f92672>=</span> :calendar.local_time<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>8<span style=color:#f92672>)</span>&gt; date_time
</span></span><span style=display:flex><span><span style=color:#f92672>{{</span>2023, 11, 11<span style=color:#f92672>}</span>, <span style=color:#f92672>{</span>21, 32, 34<span style=color:#f92672>}}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>9<span style=color:#f92672>)</span>&gt; hour
</span></span><span style=display:flex><span><span style=color:#ae81ff>21</span>
</span></span></code></pre></div><pre><code>      + ordering is not matter

        + because the result of a pattern match is always the result of the term being matched (whatever is on the right side of the match operator)

+ General behavior


  + two parts:

    + *pattern* (left side)

    + *term* (right side)

  + You assert your expectations about the right-side term. If these expectations aren’t met, an error is raised.

  + You bind some parts of the term to variables from the pattern.
</code></pre><ul><li>Matching with functions</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>def</span> my_fun(arg1, arg2) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><pre><code>+ `arg1` and `arg2` are patterns

+ the arguments you provide are matched against the patterns specified in the function definition

+ Multiclause functions


  + A clause is a function definition specified by the def expression
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>Geometry</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> area({<span style=color:#e6db74>:rectangle</span>, a, b}) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    a<span style=color:#f92672>*</span>b
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> area({<span style=color:#e6db74>:square</span>, a}) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  	a<span style=color:#f92672>*</span>a
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> area({<span style=color:#e6db74>:circle</span>, r}) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  	r <span style=color:#f92672>*</span> r <span style=color:#f92672>*</span> <span style=color:#ae81ff>3.14</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><pre><code>  + clause order is matter, the runtime tries to select the clauses, using the order in the source code

+ Guards


  + The guard is a logical expression that adds further conditions to the pattern
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>TestNum</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> test(x) <span style=color:#f92672>when</span> x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  	<span style=color:#e6db74>:negative</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> test(x) <span style=color:#f92672>when</span> x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  	<span style=color:#e6db74>:zero</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> test(x) <span style=color:#f92672>when</span> x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  	<span style=color:#e6db74>:positive</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><pre><code>  + operators and functions allowed in guards

    + Comparison operators (=\=, !=, =\<mark>
    , !
</mark>, &gt;, &lt;, &lt;=, and &gt;=)

    + Boolean operators (and and or) and negation operators (not and !)

    + Arithmetic operators (+, -, *, and /)

    + Type-check functions from the Kernel module (e.g., is_number/1, is_atom/1, and so on)

    + https://hexdocs.pm/elixir/patterns-and-guards.html#guards

  + when error raised inside guard, it won't propagate, guard expression will return `false`. The corresponding clause won’t match, but some other clause might

+ Multiclause lambdas


  + general lambda syntax
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>fn</span>
</span></span><span style=display:flex><span>  pattern_1, pattern_2 <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>  	...
</span></span><span style=display:flex><span>  pattern_3, pattern_4 <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>  	...
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>&gt; test_num <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>fn
</span></span><span style=display:flex><span>  x when is_number<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span> and x &lt; <span style=color:#ae81ff>0</span> -&gt; :negative
</span></span><span style=display:flex><span>  x when x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> -&gt; :zero
</span></span><span style=display:flex><span>  x when is_number<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span> and x &gt; <span style=color:#ae81ff>0</span> -&gt; :positive
</span></span><span style=display:flex><span>end
</span></span></code></pre></div><ul><li><p>Conditionals</p><ul><li>Branching with multiclause functions</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>&gt; defmodule Polymorphic <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  def double<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span> when is_number<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span>, <span style=color:#66d9ef>do</span>: <span style=color:#ae81ff>2</span> * x
</span></span><span style=display:flex><span>  def double<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span> when is_binary<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span>, <span style=color:#66d9ef>do</span>: x &lt;&gt; x
</span></span><span style=display:flex><span>end
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>&gt; Polymorphic.double<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iex<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>&gt; Polymorphic.double<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Jar&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;JarJar&#34;</span>
</span></span></code></pre></div><pre><code>+ Classical branching expressions

  + if and unless
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>if</span> condition <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> condition, <span style=color:#e6db74>do</span>: something, <span style=color:#e6db74>else</span>: another_thing
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unless</span> result <span style=color:#f92672>==</span> <span style=color:#e6db74>:error</span>, <span style=color:#e6db74>do</span>: send_notification(...)
</span></span></code></pre></div><pre><code>  + cond
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>cond</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  expression_1 <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>  	...
</span></span><span style=display:flex><span>  expression_2 <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>  	...
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><pre><code>  + case
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>case</span> expression <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  pattern_1 <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>  	...
</span></span><span style=display:flex><span>  pattern_2 <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>  	...
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><pre><code>    + no differences between case and multiclause functions

+ The with expression
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>def</span> extract_user(user) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> extract_login(user) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    {<span style=color:#e6db74>:error</span>, reason} <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      {<span style=color:#e6db74>:error</span>, reason}
</span></span><span style=display:flex><span>    {<span style=color:#e6db74>:ok</span>, login} <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> extract_email(user) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      	{<span style=color:#e6db74>:error</span>, reason} <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      	  {<span style=color:#e6db74>:error</span>, reason}
</span></span><span style=display:flex><span>      	{<span style=color:#e6db74>:ok</span>, email} <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      	  <span style=color:#66d9ef>case</span> extract_password(user) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>            {<span style=color:#e6db74>:error</span>, reason} <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>              {<span style=color:#e6db74>:error</span>, reason}
</span></span><span style=display:flex><span>            {<span style=color:#e6db74>:ok</span>, password} <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      	  	  %{<span style=color:#e6db74>login</span>: login, <span style=color:#e6db74>email</span>: email, <span style=color:#e6db74>password</span>: password}
</span></span><span style=display:flex><span>      	  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> extract_user(user) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  with {<span style=color:#e6db74>:ok</span>, login} <span style=color:#f92672>&lt;-</span> extract_login(user),
</span></span><span style=display:flex><span>    {<span style=color:#e6db74>:ok</span>, email} <span style=color:#f92672>&lt;-</span> extract_email(user),
</span></span><span style=display:flex><span>    {<span style=color:#e6db74>:ok</span>, password} <span style=color:#f92672>&lt;-</span> extract_password(user) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    {<span style=color:#e6db74>:ok</span>, %{<span style=color:#e6db74>login</span>: login, <span style=color:#e6db74>email</span>: email, <span style=color:#e6db74>password</span>: password}}
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><ul><li><p>Loops and iterations</p><ul><li>The principal looping tool in Elixir is <em>recursion</em></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>ListHelper</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> sum([]), <span style=color:#e6db74>do</span>: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> sum([head <span style=color:#f92672>|</span> tail]) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  	head <span style=color:#f92672>+</span> sum(tail)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><pre><code>+ Tail function calls

  + If the last thing a function does is call another function (or itself), you’re dealing with a tail call
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>def</span> original_fun(...) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  another_fun(...)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>defmodule</span> <span style=color:#a6e22e>ListHelper</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> sum(list) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  	do_sum(<span style=color:#ae81ff>0</span>, list)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>defp</span> do_sum(current_sum, []) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  	current_sum
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>defp</span> do_sum(current_sum, [head <span style=color:#f92672>|</span> tail]) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  	new_sum <span style=color:#f92672>=</span> head <span style=color:#f92672>+</span> current_sum
</span></span><span style=display:flex><span>  	do_sum(new_sum, tail)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><pre><code>+ Recognizing tail calls
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>def</span> fun(...) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> something <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    another_fun(...) <span style=color:#75715e># Tail call</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-elixir data-lang=elixir><span style=display:flex><span><span style=color:#66d9ef>def</span> fun(...) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> another_fun(...) <span style=color:#75715e># Not a tail call</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><pre><code>    + After another_fun finishes, you must increment its result by 1 to compute the final result of fun

  + https://github.com/sasa1977/elixir-in-action/blob/3rd-edition/code_samples/ch03/recursion_practice_tc.ex

+ Higher-order functions

  + A higher-order function is a type of function that takes one or more functions as its input or returns one or more functions (or both)
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>&gt; Enum.each<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1, 2, 3<span style=color:#f92672>]</span>,
</span></span><span style=display:flex><span>fn x -&gt; IO.puts<span style=color:#f92672>(</span>x<span style=color:#f92672>)</span> end
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span></code></pre></div><pre><code>+ Comprehensions
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>4<span style=color:#f92672>)</span>&gt; multiplication_table <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> x &lt;- 1..9,
</span></span><span style=display:flex><span>    y &lt;- 1..9,
</span></span><span style=display:flex><span>    into: %<span style=color:#f92672>{}</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>{{</span>x, y<span style=color:#f92672>}</span>, x*y<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>end
</span></span></code></pre></div><pre><code>+ Streams

  + A stream is a special kind of enumerable that can be useful for doing lazy composable operations over anything enumerable
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iex<span style=color:#f92672>(</span>7<span style=color:#f92672>)</span>&gt; employees
</span></span><span style=display:flex><span>  |&gt; Stream.with_index<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>  |&gt; Enum.each<span style=color:#f92672>(</span>fn <span style=color:#f92672>{</span>employee, index<span style=color:#f92672>}</span> -&gt;
</span></span><span style=display:flex><span>  IO.puts<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;#{index + 1}. #{employee}&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  end<span style=color:#f92672>)</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://al002.github.io/>Elixir in action notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>