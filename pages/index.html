<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pages | Elixir in action notes</title>
<meta name=keywords content><meta name=description content="Pages - Elixir in action notes"><meta name=author content><link rel=canonical href=https://al002.github.io/pages/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://al002.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://al002.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://al002.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://al002.github.io/apple-touch-icon.png><link rel=mask-icon href=https://al002.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://al002.github.io/pages/index.xml><link rel=alternate type=application/json href=https://al002.github.io/pages/index.json><link rel=alternate hreflang=en href=https://al002.github.io/pages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Pages"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://al002.github.io/pages/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pages"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Pages","item":"https://al002.github.io/pages/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://al002.github.io/ accesskey=h title="Elixir in action notes (Alt + H)">Elixir in action notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Pages</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chapter 1</h2></header><div class=entry-content><p>Erlang
High availability / Concurrency Fault tolerance
Erlang process is completely isolated from each other.
no memory share
a crash of one process doesn’t cause a crash of other processes
communicate via asynchronous messages
Scalability
BEAM can take advantage of all available CPU cores Distribution
processes works the same way in same BEAM instance or remote computer
Erlang-based system is automatically ready to be distributed over multiple machines
...</p></div><footer class=entry-footer><span title='2025-01-05 00:00:00 +0000 UTC'>January 5, 2025</span></footer><a class=entry-link aria-label="post link to Chapter 1" href=https://al002.github.io/pages/chapter-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chapter 2</h2></header><div class=entry-content><p>Organizing code
Modules
A module is a collection of functions, somewhat like a namespace defmodule Geometry do def rectangle_area(a, b) do a*b end end Functions def rectangle_area(a, b) do ... end def rectangle_area(a, b), do: a * b + Arity + the number of arguments a function receives + A function is uniquely identified by its containing module, name, and arity + Rectangle.area/2, where /2 denotes the function’s arity. + same name but different arities are two different functions + commonly, a lower-arity function delegates to a higher-arity function, providing some default arguments + `\\` operator followed by the argument’s default value defmodule Calculator do def add(a, b \\ 0), do: a + b end + generates two functions defmodule Calculator do def add(a), do: add(a, 0) def add(a, b), do: a+b end + cannot accept a variable number of arguments + Visibility + `def` macro is `exported` + `defp` macro is private + can be used only inside the module it’s defined in Imports and alias # Import defmodule MyModule do import IO def my_function do puts "Calling imported function." end end + Importing a module allows to call its public functions without prefixing them with the module name # Alias defmodule MyModule do alias IO, as: MyIO def my_function do MyIO.puts("Calling imported function.") end end defmodule MyModule do alias Geometry.Rectangle, as: Rectangle def my_function do Rectangle.area(...) end end Module attributes
...</p></div><footer class=entry-footer><span title='2025-01-04 00:00:00 +0000 UTC'>January 4, 2025</span></footer><a class=entry-link aria-label="post link to Chapter 2" href=https://al002.github.io/pages/chapter-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chapter 3</h2></header><div class=entry-content><p>Pattern matching
= operator is called the match operator
assignment-like expression is an example of pattern matching iex(1)> person = {"Bob", 25} + Matching tuples iex(1)> {name, age} = {"Bob", 25} + Matching constants iex(2)> person = {:person, "Bob", 25} iex(3)> {:person, name, age} = person {:person, "Bob", 25} {:ok, contents} = File.read("my_app.config") + By using constants in patterns, you tighten the match, ensuring some part of the right side has a specific value. + `^` pin operator iex(7)> expected_name = "Bob" "Bob" iex(8)> {^expected_name, _} = {"Bob", 25} {"Bob", 25} iex(9)> {^expected_name, _} = {"Alice", 30} ** (MatchError) no match of right hand side value: {"Alice", 30} + Using `^expected_name` in patterns indicates you expect the value of the variable `expected_name` to be in the appropriate position in the right-side term + like `({"Bob", _} = …)` + Matching lists iex(1)> [first, second, third] = [1, 2, 3] [1, 2, 3] iex(3)> [head | tail] = [1, 2, 3] [1, 2, 3] iex(4)> head 1 iex(5)> tail [2, 3] + Matching maps iex(1)> %{name: name, age: age} = %{name: "Bob", age: 25} %{age: 25, name: "Bob"} iex(6)> %{age: age, works_at: works_at} = %{name: "Bob", age: 25} ** (MatchError) no match of right hand side value + Matching bitstrings and binaries iex(6)> &lt;&lt;b1, rest :: binary>> = binary &lt;&lt;1, 2, 3>> iex(7)> b1 1 iex(8)> rest &lt;&lt;2, 3>> + Matching binary strings iex(16)> command = "ping www.example.com" "ping www.example.com" iex(17)> "ping " &lt;> url = command "ping www.example.com" iex(18)> url "www.example.com" + Compound matches + match expression + `pattern = expression` + `iex(2)> a = 1 + 3` + 1 The expression on the right side is evaluated. + 2 The resulting value is matched against the left-side pattern. + 3 Variables from the pattern are bound. + 4 The result of the match expression is the result of the right-side term + match chaining iex(3)> a = (b = 1 + 3) 4 iex(4)> a =b=1+3 4 + 1 The expression 1 + 3 is evaluated. + 2 The result (4) is matched against the pattern b. + 3 The result of the inner match (which is, again, 4) is matched against the pattern a. iex(6)> date_time = {_, {hour, _, _}} = :calendar.local_time() iex(7)> {_, {hour, _, _}} = date_time = :calendar.local_time() iex(8)> date_time {{2023, 11, 11}, {21, 32, 34}} iex(9)> hour 21 + ordering is not matter + because the result of a pattern match is always the result of the term being matched (whatever is on the right side of the match operator) + General behavior + two parts: + *pattern* (left side) + *term* (right side) + You assert your expectations about the right-side term. If these expectations aren’t met, an error is raised. + You bind some parts of the term to variables from the pattern. Matching with functions def my_fun(arg1, arg2) do ... end + `arg1` and `arg2` are patterns + the arguments you provide are matched against the patterns specified in the function definition + Multiclause functions + A clause is a function definition specified by the def expression defmodule Geometry do def area({:rectangle, a, b}) do a*b end def area({:square, a}) do a*a end def area({:circle, r}) do r * r * 3.14 end end + clause order is matter, the runtime tries to select the clauses, using the order in the source code + Guards + The guard is a logical expression that adds further conditions to the pattern defmodule TestNum do def test(x) when x &lt; 0 do :negative end def test(x) when x == 0 do :zero end def test(x) when x > 0 do :positive end end + operators and functions allowed in guards + Comparison operators (=\=, !=, =\ , ! , >, &lt;, &lt;=, and >=) + Boolean operators (and and or) and negation operators (not and !) + Arithmetic operators (+, -, *, and /) + Type-check functions from the Kernel module (e.g., is_number/1, is_atom/1, and so on) + https://hexdocs.pm/elixir/patterns-and-guards.html#guards + when error raised inside guard, it won't propagate, guard expression will return `false`. The corresponding clause won’t match, but some other clause might + Multiclause lambdas + general lambda syntax fn pattern_1, pattern_2 -> ... pattern_3, pattern_4 -> ... ... end iex(3)> test_num = fn x when is_number(x) and x &lt; 0 -> :negative x when x == 0 -> :zero x when is_number(x) and x > 0 -> :positive end Conditionals
...</p></div><footer class=entry-footer><span title='2025-01-03 00:00:00 +0000 UTC'>January 3, 2025</span></footer><a class=entry-link aria-label="post link to Chapter 3" href=https://al002.github.io/pages/chapter-3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chapter 4</h2></header><div class=entry-content><p>Basic principles of abstraction in Elixir
A module is in charge of abstracting some behavior.
The module’s functions usually expect an instance of the abstraction as the first argument.
Modifier functions return a modified version of the abstraction.
Query functions return some other type of data.
Abstracting with modules
defmodule TodoList do ... def add_entry(todo_list, entry) do entry = Map.put(entry, :id, todo_list.next_id) new_entries = Map.put( todo_list.entries, todo_list.next_id, entry ) %TodoList{todo_list | entries: new_entries, next_id: todo_list.next_id + 1 } end ... end + The entire operation will be atomic + This is the consequence of immutability. The effect of adding an entry is visible to others only when the `add_entry/2` function finishes and its result is taken into a variable. If something goes wrong and you raise an error, the effect of any transformations won’t be visible Polymorphism with protocols
...</p></div><footer class=entry-footer><span title='2025-01-02 00:00:00 +0000 UTC'>January 2, 2025</span></footer><a class=entry-link aria-label="post link to Chapter 4" href=https://al002.github.io/pages/chapter-4/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chapter 5</h2></header><div class=entry-content><p>Concurrency primitives
Creating processes iex(1)> run_query = fn query_def -> Process.sleep(2000) "#{query_def} result" end spawn(fn -> expression_1 ... expression_n end) iex(4)> spawn(fn -> query_result = run_query.("query 1") IO.puts(query_result) end) #PID&lt;0.48.0> query 1 result # Printed after 2 seconds iex(5)> async_query = fn query_def -> spawn(fn -> query_result = run_query.(query_def) IO.puts(query_result) end) end iex(6)> async_query.("query 1") #PID&lt;0.52.0> query 1 result # 2 senconds later iex(7)> Enum.each(1..5, &amp;async_query.("query #{&amp;1}")) :ok query 1 result query 2 result query 3 result query 4 result query 5 result # 2 seconds later Message passing
...</p></div><footer class=entry-footer><span title='2025-01-01 00:00:00 +0000 UTC'>January 1, 2025</span></footer><a class=entry-link aria-label="post link to Chapter 5" href=https://al002.github.io/pages/chapter-5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chapter 6</h2></header><div class=entry-content><p>Generic server processes
start
init
handle_call is synchronous request
handle_cast is asynchronous request
handle_info handle plain messages, not specific to GenServer
callback function execute in server process
Plugging into GenServer
defmodule KeyValueStore do use GenServer end + `use` macro + During compilation, when this instruction is encountered, the specific macro from the `GenServer` module is invoked. That macro then injects several functions into the calling module + use `@impl GenServer` to tells the compiler that the function about to be defined is a callback function for the GenServer behaviour defmodule EchoServer do use GenServer @impl GenServer def handle_call(some_request, server_state) do {:reply, some_request, server_state} end end + name registration GenServer.start( CallbackModule, init_param, name: :some_name ) # During compilation, __MODULE__ is replaced with the name of the module where the code resides: defmodule KeyValueStore do def start() do GenServer.start(__MODULE__, nil, name: __MODULE__) end def put(key, value) do GenServer.cast(__MODULE__, {:put, key, value}) end ... end + `{:stop, reason}` or `:ignore` to stop server process + `handle_call` return `{:stop, reason, response, new_state}` Process lifecycle ...</p></div><footer class=entry-footer><span title='2024-12-31 00:00:00 +0000 UTC'>December 31, 2024</span></footer><a class=entry-link aria-label="post link to Chapter 6" href=https://al002.github.io/pages/chapter-6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chapter 7</h2></header><div class=entry-content><p>Mix project conventions
place module under a common top-level alias
like Todo.List, Todo.Server one file, one module
except small helper module or protocol implementation for the module filename should be an underscore-case
TodoServer module would reside in todo_server.ex file in the lib folder The folder structure should correspond to multipart module names
Todo.Server should reside in the lib/todo/server.ex file Addressing the process bottleneck
use process considerations
The code must manage a long-living state
...</p></div><footer class=entry-footer><span title='2024-12-30 00:00:00 +0000 UTC'>December 30, 2024</span></footer><a class=entry-link aria-label="post link to Chapter 7" href=https://al002.github.io/pages/chapter-7/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chapter 8</h2></header><div class=entry-content><p>Runtime errors
error types
errors, exits, and throws
error
raise("Something went wrong") ** (RuntimeError) Something went wrong + exit iex(2)> spawn(fn -> exit("I'm done") IO.puts("This doesn't happen") end) + throws iex(3)> throw(:thrown_value) ** (throw) :thrown_value Handling errors try do ... catch error_type, error_value -> ... end + `catch` blocks are patterns + tail call isn’t possible if the function call resides in a `try` expression A run-time error has a type, which can be :error, :exit, or :throw
...</p></div><footer class=entry-footer><span title='2024-12-29 00:00:00 +0000 UTC'>December 29, 2024</span></footer><a class=entry-link aria-label="post link to Chapter 8" href=https://al002.github.io/pages/chapter-8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chapter 9</h2></header><div class=entry-content><p>Use Registry to register process and then discover it
iex(1)> Registry.start_link(name: :my_registry, keys: :unique) iex(2)> spawn(fn -> Registry.register(:my_registry, {:database_worker, 1}, nil) receive do msg -> IO.puts("got message #{inspect(msg)}") end end) iex(3)> [{db_worker_pid, _value}] = Registry.lookup( :my_registry, {:database_worker, 1} ) iex(4)> send(db_worker_pid, :some_message) got message :some_message Via tuples
allows you to use an arbitrary third-party registry to register OTP-compliant processes, such as GenServer and supervisors
GenServer.start_link(callback_module, some_arg, name: some_name)
...</p></div><footer class=entry-footer><span title='2024-12-28 00:00:00 +0000 UTC'>December 28, 2024</span></footer><a class=entry-link aria-label="post link to Chapter 9" href=https://al002.github.io/pages/chapter-9/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chapter 10</h2></header><div class=entry-content><p>Tasks
The Task module can be used to concurrently run a job
Awaited tasks
An awaited task is a process that executes some function, sends the function result back to the starter process, and then terminates iex(1)> long_job = fn -> Process.sleep(2000) :some_result end iex(2)> task = Task.async(long_job) # await will wait response from the task process # default 5 seconds to timeout iex(3)> Task.await(task) :some_result + if any task process crashes, the starter process will crash too + `Task.async/1` has all-or-nothing semantics Non-awaited tasks iex(1)> Task.start_link(fn -> Process.sleep(1000) IO.puts("Hello from task") end) {:ok, #PID&lt;0.89.0>} # Result of Task.start_link/1 Hello from task! # Printed 1 second later Supervising dynamic tasks iex(1)> Task.Supervisor.start_link(name: MyTaskSupervisor) iex(2)> Task.Supervisor.start_child( MyTaskSupervisor, fn -> IO.puts("Task started") Process.sleep(2000) IO.puts("Task stopping") end ) {:ok, #PID&lt;0.118.0>} Task started Task stopping Agents
...</p></div><footer class=entry-footer><span title='2024-12-27 00:00:00 +0000 UTC'>December 27, 2024</span></footer><a class=entry-link aria-label="post link to Chapter 10" href=https://al002.github.io/pages/chapter-10/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://al002.github.io/pages/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://al002.github.io/>Elixir in action notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>